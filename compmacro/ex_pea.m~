%%
% This script solves the stochastic growth model
% using the parameterized expectation algorithm
%

% Administrative commands

clear all
clc

rand('state',1)

%%
% Initialize: set model's parameters

tic;            % Start Clock counter

alpha=0.3;      % Production function
beta =0.95;     % Subjective discount factor
delta =0.1;        % Capital Depreciation
gama = 1;
rho  = 0.9;      % Persitence of productuvity stochastic component
sigma = 0.01; % Standard Deviation of epsilon

%%
% Characterize the steady state

zss = 0;
Kss = (alpha*beta/(1-beta*(1-delta)))^(1/(1-alpha));    % Capital stock at the steady state
Css = Kss^alpha - delta*Kss;  

%%
% Step 1. Initialize 

T=1000;         % Time periods to simulate
Tbar = 0.1*T;     % Time periods to discard
lambda=1;       % Smoothing parameter
tol = 1e-6;     % Tolerance level
crit=1;         % ||theta0-theta1|| stopping criterion

Tpick		= Tbar+1:T-1;   % Tbar+1,...,T-1
T1pick		= Tbar+2:T;     % Tbar+2,...,T

theta0 = [0.5   -0.7   -0.4    0.1   -0.1   -0.1]';

fprintf('---------------------------------\n')
fprintf(' Initial value for theta \n')
fprintf('---------------------------------\n')
for i=1:6
fprintf(' theta0(%g) = %6.3f  \n',i,theta0(i))
end
fprintf('---------------------------------\n')

%%
% Step 2: Generate a sequence for aggregate productivity

e		= sigma*randn(T,1);
z		= zeros(T,1);
z(1)	= e(1);
for i	= 2:T;
   z(i)=rho*z(i-1)+e(i);
end


iter	= 1;
while crit>tol;
   %
   % Simulated path
   %
   k		= zeros(T+1,1); % Kt
   lb		= zeros(T,1);   % Phi(K,z)
   X		= zeros(T,length(theta0));  % X vector
   k(1)	= Kss;
   for i = 1:T;
       X(i,:)= [1 log(k(i)) z(i) log(k(i))*log(k(i)) z(i)*z(i) log(k(i))*z(i)];
       lb(i)	= exp(X(i,:)*theta0);
       ct(i,1) = lb(i)^(-1/gama);
       k(i+1)=exp(z(i))*k(i)^alpha+(1-delta)*k(i)-ct(i);
       
       It=(k(i+1)-(1-delta)*k(i));
       if It<0
           k(i+1)=(1-delta)*k(i);
           It=(k(i+1)-(1-delta)*k(i));
       end
       
       ct(i) = exp(z(i))*k(i)^alpha - It; %Calculates c_t from resource constraint
   end
   yt1 = beta*(ct(T1pick).^(-gama)).*(alpha*exp(z(T1pick)).*k(T1pick).^(alpha-1)+1-delta);
   thetat		= X(Tpick,:)\log(yt1);
   theta1		= lambda*thetat+(1-lambda)*theta0;
   crit	= norm(theta1-theta0);
   theta0		= theta1;
    
   disp(sprintf('Iteration # %2d \tCriterion: %g',iter,crit))
   iter=iter+1;
end;

thetaopt = theta1;
fprintf('---------------------------------\n')
fprintf(' Final value for theta \n')
fprintf('---------------------------------\n')
for i=1:6
fprintf('theta(%g) = %6.3f  \n',i,thetaopt(i))
end
fprintf('\n')
fprintf('x = [1 log(k) z log(k)*log(k) z^2 log(k)*z] \n')
fprintf('---------------------------------\n')

zbar=z(Tpick,1);
kbar=k(Tpick,1);
k1bar=k(T1pick,1);
cbar=ct(Tpick,1);
ibar=k(T1pick)-(1-delta)*k(Tpick);

Kp = inline('exp([ones(size(k,1),1) z z.^2 log(k) log(k).^2 z.*log(k)]*th)','k','z','bhat');


%{
subplot(3,1,1)
plot(1:T,KKt(2:end))
title('Sample path for K_{t+1}')
subplot(3,1,2)
plot(1:T,CCt)
title('Sample path for C_{t}')
subplot(3,1,3)
plot(1:T,YYt)
title('Sample path for Y_{t}')
%}